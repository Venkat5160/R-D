//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Linq.Expressions;
using System.Data.Objects;
using System.Linq;
using System.Reflection;
using smsg_DAL;
using FastDatabaseQuery;
using System.Data.Entity;

namespace smsg_DAL
{
    
    public partial class smsg_Message_FindDB : FindInDatabase<smsg_Message>
    {
        
        public static Expression<Func<smsg_Message, long>> exp_IDMessage = (item => item.IDMessage );
        public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessage = value => (item => 
                // item.IDMessage != null  &&  
                item.IDMessage == value);
        //TODO: find who supports this!   
    	////    a// a
        //public static Func<long,long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageBetween = (value1,value2) => (item => item.IDMessage> value1 && item.IDMessage<value2);
    	//public static Func<long,long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageBetweenEq = (value1,value2) => (item => item.IDMessage >= value1 && item.IDMessage <= value2);
    	//public static Func<long,long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageBetweenEqDate = (value1,value2) =>{
    	//		value1=
    	//			//value1.Value.Date ;
    	//			value1.Date ;
    	//		value2=
    	//			//value2.Value.Date.AddDays(1) ;
    	//			value2.Date.AddDays(1) ;	
    	//		return (item => item.IDMessage >= value1 && item.IDMessage < value2);
    	// };
    	//public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageGreater = (value =>(item => item.IDMessage > value));
    	//public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageGreaterEq = (value => (item =>item.IDMessage >= value));
    	//public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageLess = (value => (item =>item.IDMessage < value));
    	//public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageLessEq = (value => (item =>item.IDMessage <= value));
        //public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageGreater = value => (item => HelperExpressions.GreaterThan<long>()(item.IDMessage ,value));
        //public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageLess = value => (item => HelperExpressions.GreaterThan<long>()(value, item.IDMessage ));
        // public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageContains = value => (item =>  item.IDMessage != null  &&  item.IDMessage.Contains(value));
        // public static Func<long, Expression<Func<smsg_Message, bool>>> fexp_IDMessageStartsWith = value => (item =>  item.IDMessage != null  &&  item.IDMessage.StartsWith(value));
    	// public IQueryable<smsg_Message> LoadFrom_IDMessageContainsQ(string value)
    	// {
    	//  return this.ObjectSetWithInclude().Where(fexp_IDMessageContains(value));
    	//  }
    	// public static Func<long,string, Expression<Func<smsg_Message, bool>>> fexp_IDMessageContainsMultiple = (value,separator) => 
    	//	{
    	//		value=value.ToLower();
    	//		var arr=value.Split(new string[1]{separator}, StringSplitOptions.RemoveEmptyEntries);
    	//		switch(arr.Length)//TODO: use a better expression here rahter than based on length 
    	//		{
    	//			case 1:
    	//				return (item =>  item.IDMessage != null  &&  item.IDMessage.ToLower().Contains(value));
    	//			case 2:
    	//				 {
    	//				  string v1=arr[0].Replace(separator,"");
    	//				  string v2=arr[1].Replace(separator,"");				
    	//				 return (item =>  item.IDMessage != null  &&  item.IDMessage.ToLower().Contains(v1)  &&  item.IDMessage.ToLower().Contains(v2) );		
    	//				}
    	//			default:
    	//				 {
    	//				   string v1=arr[0].Replace(separator,"");
    	//				  string v2=arr[1].Replace(separator,"");
    	//				  string v3=arr[2].Replace(separator,"");
    	//				return (item =>  item.IDMessage != null  &&  item.IDMessage.ToLower().Contains(v1) &&  item.IDMessage.ToLower().Contains(v2) &&  item.IDMessage.ToLower().Contains(v3) );
    	//				}
    	//
    	//		}
    	//			
    	//
    	//	};	 
    	// public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_IDMessageContainsMultipleDef = value => fexp_IDMessageContainsMultiple(value, "%");
        
        public static Expression<Func<smsg_Message, string>> exp_Subject = (item => item.Subject );
        public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_Subject = value => (item => 
                // item.Subject != null  &&  
                item.Subject == value);
        //TODO: find who supports this!   
    	////    a// a
        //public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_SubjectBetween = (value1,value2) => (item => item.Subject> value1 && item.Subject<value2);
    	//public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_SubjectBetweenEq = (value1,value2) => (item => item.Subject >= value1 && item.Subject <= value2);
    	//public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_SubjectBetweenEqDate = (value1,value2) =>{
    	//		value1=
    	//			//value1.Value.Date ;
    	//			value1.Date ;
    	//		value2=
    	//			//value2.Value.Date.AddDays(1) ;
    	//			value2.Date.AddDays(1) ;	
    	//		return (item => item.Subject >= value1 && item.Subject < value2);
    	// };
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectGreater = (value =>(item => item.Subject > value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectGreaterEq = (value => (item =>item.Subject >= value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectLess = (value => (item =>item.Subject < value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectLessEq = (value => (item =>item.Subject <= value));
        //public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectGreater = value => (item => HelperExpressions.GreaterThan<string>()(item.Subject ,value));
        //public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectLess = value => (item => HelperExpressions.GreaterThan<string>()(value, item.Subject ));
         public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectContains = value => (item =>  item.Subject != null  &&  item.Subject.Contains(value));
         public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectStartsWith = value => (item =>  item.Subject != null  &&  item.Subject.StartsWith(value));
    	 public IQueryable<smsg_Message> LoadFrom_SubjectContainsQ(string value)
    	 {
    	  return this.ObjectSetWithInclude().Where(fexp_SubjectContains(value));
    	  }
    	 public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_SubjectContainsMultiple = (value,separator) => 
    		{
    			value=value.ToLower();
    			var arr=value.Split(new string[1]{separator}, StringSplitOptions.RemoveEmptyEntries);
    			switch(arr.Length)//TODO: use a better expression here rahter than based on length 
    			{
    				case 1:
    					return (item =>  item.Subject != null  &&  item.Subject.ToLower().Contains(value));
    				case 2:
    					 {
    					  string v1=arr[0].Replace(separator,"");
    					  string v2=arr[1].Replace(separator,"");				
    					 return (item =>  item.Subject != null  &&  item.Subject.ToLower().Contains(v1)  &&  item.Subject.ToLower().Contains(v2) );		
    					}
    				default:
    					 {
    					   string v1=arr[0].Replace(separator,"");
    					  string v2=arr[1].Replace(separator,"");
    					  string v3=arr[2].Replace(separator,"");
    					return (item =>  item.Subject != null  &&  item.Subject.ToLower().Contains(v1) &&  item.Subject.ToLower().Contains(v2) &&  item.Subject.ToLower().Contains(v3) );
    					}
    	
    			}
    				
    	
    		};	 
    	 public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_SubjectContainsMultipleDef = value => fexp_SubjectContainsMultiple(value, "%");
        
        public static Expression<Func<smsg_Message, string>> exp_Body = (item => item.Body );
        public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_Body = value => (item => 
                 item.Body != null  &&  
                item.Body == value);
        //TODO: find who supports this!   
    	////    a a
        //public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_BodyBetween = (value1,value2) => (item => item.Body> value1 && item.Body<value2);
    	//public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_BodyBetweenEq = (value1,value2) => (item => item.Body >= value1 && item.Body <= value2);
    	//public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_BodyBetweenEqDate = (value1,value2) =>{
    	//		value1=
    	//			value1.Value.Date ;
    	//			//value1.Date ;
    	//		value2=
    	//			value2.Value.Date.AddDays(1) ;
    	//			//value2.Date.AddDays(1) ;	
    	//		return (item => item.Body >= value1 && item.Body < value2);
    	// };
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyGreater = (value =>(item => item.Body > value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyGreaterEq = (value => (item =>item.Body >= value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyLess = (value => (item =>item.Body < value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyLessEq = (value => (item =>item.Body <= value));
        //public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyGreater = value => (item => HelperExpressions.GreaterThan<string>()(item.Body ,value));
        //public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyLess = value => (item => HelperExpressions.GreaterThan<string>()(value, item.Body ));
         public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyContains = value => (item =>  item.Body != null  &&  item.Body.Contains(value));
         public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyStartsWith = value => (item =>  item.Body != null  &&  item.Body.StartsWith(value));
    	 public IQueryable<smsg_Message> LoadFrom_BodyContainsQ(string value)
    	 {
    	  return this.ObjectSetWithInclude().Where(fexp_BodyContains(value));
    	  }
    	 public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_BodyContainsMultiple = (value,separator) => 
    		{
    			value=value.ToLower();
    			var arr=value.Split(new string[1]{separator}, StringSplitOptions.RemoveEmptyEntries);
    			switch(arr.Length)//TODO: use a better expression here rahter than based on length 
    			{
    				case 1:
    					return (item =>  item.Body != null  &&  item.Body.ToLower().Contains(value));
    				case 2:
    					 {
    					  string v1=arr[0].Replace(separator,"");
    					  string v2=arr[1].Replace(separator,"");				
    					 return (item =>  item.Body != null  &&  item.Body.ToLower().Contains(v1)  &&  item.Body.ToLower().Contains(v2) );		
    					}
    				default:
    					 {
    					   string v1=arr[0].Replace(separator,"");
    					  string v2=arr[1].Replace(separator,"");
    					  string v3=arr[2].Replace(separator,"");
    					return (item =>  item.Body != null  &&  item.Body.ToLower().Contains(v1) &&  item.Body.ToLower().Contains(v2) &&  item.Body.ToLower().Contains(v3) );
    					}
    	
    			}
    				
    	
    		};	 
    	 public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_BodyContainsMultipleDef = value => fexp_BodyContainsMultiple(value, "%");
        
        public static Expression<Func<smsg_Message, string>> exp_FromUser = (item => item.FromUser );
        public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUser = value => (item => 
                // item.FromUser != null  &&  
                item.FromUser == value);
        //TODO: find who supports this!   
    	////    a// a
        //public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_FromUserBetween = (value1,value2) => (item => item.FromUser> value1 && item.FromUser<value2);
    	//public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_FromUserBetweenEq = (value1,value2) => (item => item.FromUser >= value1 && item.FromUser <= value2);
    	//public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_FromUserBetweenEqDate = (value1,value2) =>{
    	//		value1=
    	//			//value1.Value.Date ;
    	//			value1.Date ;
    	//		value2=
    	//			//value2.Value.Date.AddDays(1) ;
    	//			value2.Date.AddDays(1) ;	
    	//		return (item => item.FromUser >= value1 && item.FromUser < value2);
    	// };
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserGreater = (value =>(item => item.FromUser > value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserGreaterEq = (value => (item =>item.FromUser >= value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserLess = (value => (item =>item.FromUser < value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserLessEq = (value => (item =>item.FromUser <= value));
        //public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserGreater = value => (item => HelperExpressions.GreaterThan<string>()(item.FromUser ,value));
        //public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserLess = value => (item => HelperExpressions.GreaterThan<string>()(value, item.FromUser ));
         public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserContains = value => (item =>  item.FromUser != null  &&  item.FromUser.Contains(value));
         public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserStartsWith = value => (item =>  item.FromUser != null  &&  item.FromUser.StartsWith(value));
    	 public IQueryable<smsg_Message> LoadFrom_FromUserContainsQ(string value)
    	 {
    	  return this.ObjectSetWithInclude().Where(fexp_FromUserContains(value));
    	  }
    	 public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_FromUserContainsMultiple = (value,separator) => 
    		{
    			value=value.ToLower();
    			var arr=value.Split(new string[1]{separator}, StringSplitOptions.RemoveEmptyEntries);
    			switch(arr.Length)//TODO: use a better expression here rahter than based on length 
    			{
    				case 1:
    					return (item =>  item.FromUser != null  &&  item.FromUser.ToLower().Contains(value));
    				case 2:
    					 {
    					  string v1=arr[0].Replace(separator,"");
    					  string v2=arr[1].Replace(separator,"");				
    					 return (item =>  item.FromUser != null  &&  item.FromUser.ToLower().Contains(v1)  &&  item.FromUser.ToLower().Contains(v2) );		
    					}
    				default:
    					 {
    					   string v1=arr[0].Replace(separator,"");
    					  string v2=arr[1].Replace(separator,"");
    					  string v3=arr[2].Replace(separator,"");
    					return (item =>  item.FromUser != null  &&  item.FromUser.ToLower().Contains(v1) &&  item.FromUser.ToLower().Contains(v2) &&  item.FromUser.ToLower().Contains(v3) );
    					}
    	
    			}
    				
    	
    		};	 
    	 public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_FromUserContainsMultipleDef = value => fexp_FromUserContainsMultiple(value, "%");
        
        public static Expression<Func<smsg_Message, string>> exp_ToUser = (item => item.ToUser );
        public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUser = value => (item => 
                // item.ToUser != null  &&  
                item.ToUser == value);
        //TODO: find who supports this!   
    	////    a// a
        //public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_ToUserBetween = (value1,value2) => (item => item.ToUser> value1 && item.ToUser<value2);
    	//public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_ToUserBetweenEq = (value1,value2) => (item => item.ToUser >= value1 && item.ToUser <= value2);
    	//public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_ToUserBetweenEqDate = (value1,value2) =>{
    	//		value1=
    	//			//value1.Value.Date ;
    	//			value1.Date ;
    	//		value2=
    	//			//value2.Value.Date.AddDays(1) ;
    	//			value2.Date.AddDays(1) ;	
    	//		return (item => item.ToUser >= value1 && item.ToUser < value2);
    	// };
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserGreater = (value =>(item => item.ToUser > value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserGreaterEq = (value => (item =>item.ToUser >= value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserLess = (value => (item =>item.ToUser < value));
    	//public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserLessEq = (value => (item =>item.ToUser <= value));
        //public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserGreater = value => (item => HelperExpressions.GreaterThan<string>()(item.ToUser ,value));
        //public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserLess = value => (item => HelperExpressions.GreaterThan<string>()(value, item.ToUser ));
         public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserContains = value => (item =>  item.ToUser != null  &&  item.ToUser.Contains(value));
         public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserStartsWith = value => (item =>  item.ToUser != null  &&  item.ToUser.StartsWith(value));
    	 public IQueryable<smsg_Message> LoadFrom_ToUserContainsQ(string value)
    	 {
    	  return this.ObjectSetWithInclude().Where(fexp_ToUserContains(value));
    	  }
    	 public static Func<string,string, Expression<Func<smsg_Message, bool>>> fexp_ToUserContainsMultiple = (value,separator) => 
    		{
    			value=value.ToLower();
    			var arr=value.Split(new string[1]{separator}, StringSplitOptions.RemoveEmptyEntries);
    			switch(arr.Length)//TODO: use a better expression here rahter than based on length 
    			{
    				case 1:
    					return (item =>  item.ToUser != null  &&  item.ToUser.ToLower().Contains(value));
    				case 2:
    					 {
    					  string v1=arr[0].Replace(separator,"");
    					  string v2=arr[1].Replace(separator,"");				
    					 return (item =>  item.ToUser != null  &&  item.ToUser.ToLower().Contains(v1)  &&  item.ToUser.ToLower().Contains(v2) );		
    					}
    				default:
    					 {
    					   string v1=arr[0].Replace(separator,"");
    					  string v2=arr[1].Replace(separator,"");
    					  string v3=arr[2].Replace(separator,"");
    					return (item =>  item.ToUser != null  &&  item.ToUser.ToLower().Contains(v1) &&  item.ToUser.ToLower().Contains(v2) &&  item.ToUser.ToLower().Contains(v3) );
    					}
    	
    			}
    				
    	
    		};	 
    	 public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_ToUserContainsMultipleDef = value => fexp_ToUserContainsMultiple(value, "%");
        
        public static Expression<Func<smsg_Message, System.DateTime>> exp_DateInserted = (item => item.DateInserted );
        public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInserted = value => (item => 
                // item.DateInserted != null  &&  
                item.DateInserted == value);
        //TODO: find who supports this!   
    	//    a// a
        public static Func<System.DateTime,System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedBetween = (value1,value2) => (item => item.DateInserted> value1 && item.DateInserted<value2);
    	public static Func<System.DateTime,System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedBetweenEq = (value1,value2) => (item => item.DateInserted >= value1 && item.DateInserted <= value2);
    	public static Func<System.DateTime,System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedBetweenEqDate = (value1,value2) =>{
    			value1=
    				//value1.Value.Date ;
    				value1.Date ;
    			value2=
    				//value2.Value.Date.AddDays(1) ;
    				value2.Date.AddDays(1) ;	
    			return (item => item.DateInserted >= value1 && item.DateInserted < value2);
    	 };
    	public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedGreater = (value =>(item => item.DateInserted > value));
    	public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedGreaterEq = (value => (item =>item.DateInserted >= value));
    	public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedLess = (value => (item =>item.DateInserted < value));
    	public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedLessEq = (value => (item =>item.DateInserted <= value));
        //public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedGreater = value => (item => HelperExpressions.GreaterThan<System.DateTime>()(item.DateInserted ,value));
        //public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedLess = value => (item => HelperExpressions.GreaterThan<System.DateTime>()(value, item.DateInserted ));
        // public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedContains = value => (item =>  item.DateInserted != null  &&  item.DateInserted.Contains(value));
        // public static Func<System.DateTime, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedStartsWith = value => (item =>  item.DateInserted != null  &&  item.DateInserted.StartsWith(value));
    	// public IQueryable<smsg_Message> LoadFrom_DateInsertedContainsQ(string value)
    	// {
    	//  return this.ObjectSetWithInclude().Where(fexp_DateInsertedContains(value));
    	//  }
    	// public static Func<System.DateTime,string, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedContainsMultiple = (value,separator) => 
    	//	{
    	//		value=value.ToLower();
    	//		var arr=value.Split(new string[1]{separator}, StringSplitOptions.RemoveEmptyEntries);
    	//		switch(arr.Length)//TODO: use a better expression here rahter than based on length 
    	//		{
    	//			case 1:
    	//				return (item =>  item.DateInserted != null  &&  item.DateInserted.ToLower().Contains(value));
    	//			case 2:
    	//				 {
    	//				  string v1=arr[0].Replace(separator,"");
    	//				  string v2=arr[1].Replace(separator,"");				
    	//				 return (item =>  item.DateInserted != null  &&  item.DateInserted.ToLower().Contains(v1)  &&  item.DateInserted.ToLower().Contains(v2) );		
    	//				}
    	//			default:
    	//				 {
    	//				   string v1=arr[0].Replace(separator,"");
    	//				  string v2=arr[1].Replace(separator,"");
    	//				  string v3=arr[2].Replace(separator,"");
    	//				return (item =>  item.DateInserted != null  &&  item.DateInserted.ToLower().Contains(v1) &&  item.DateInserted.ToLower().Contains(v2) &&  item.DateInserted.ToLower().Contains(v3) );
    	//				}
    	//
    	//		}
    	//			
    	//
    	//	};	 
    	// public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_DateInsertedContainsMultipleDef = value => fexp_DateInsertedContainsMultiple(value, "%");
        
        public static Expression<Func<smsg_Message, bool>> exp_MessageRead = (item => item.MessageRead );
        public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageRead = value => (item => 
                // item.MessageRead != null  &&  
                item.MessageRead == value);
        //TODO: find who supports this!   
    	////    a// a
        //public static Func<bool,bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadBetween = (value1,value2) => (item => item.MessageRead> value1 && item.MessageRead<value2);
    	//public static Func<bool,bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadBetweenEq = (value1,value2) => (item => item.MessageRead >= value1 && item.MessageRead <= value2);
    	//public static Func<bool,bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadBetweenEqDate = (value1,value2) =>{
    	//		value1=
    	//			//value1.Value.Date ;
    	//			value1.Date ;
    	//		value2=
    	//			//value2.Value.Date.AddDays(1) ;
    	//			value2.Date.AddDays(1) ;	
    	//		return (item => item.MessageRead >= value1 && item.MessageRead < value2);
    	// };
    	//public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadGreater = (value =>(item => item.MessageRead > value));
    	//public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadGreaterEq = (value => (item =>item.MessageRead >= value));
    	//public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadLess = (value => (item =>item.MessageRead < value));
    	//public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadLessEq = (value => (item =>item.MessageRead <= value));
        //public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadGreater = value => (item => HelperExpressions.GreaterThan<bool>()(item.MessageRead ,value));
        //public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadLess = value => (item => HelperExpressions.GreaterThan<bool>()(value, item.MessageRead ));
        // public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadContains = value => (item =>  item.MessageRead != null  &&  item.MessageRead.Contains(value));
        // public static Func<bool, Expression<Func<smsg_Message, bool>>> fexp_MessageReadStartsWith = value => (item =>  item.MessageRead != null  &&  item.MessageRead.StartsWith(value));
    	// public IQueryable<smsg_Message> LoadFrom_MessageReadContainsQ(string value)
    	// {
    	//  return this.ObjectSetWithInclude().Where(fexp_MessageReadContains(value));
    	//  }
    	// public static Func<bool,string, Expression<Func<smsg_Message, bool>>> fexp_MessageReadContainsMultiple = (value,separator) => 
    	//	{
    	//		value=value.ToLower();
    	//		var arr=value.Split(new string[1]{separator}, StringSplitOptions.RemoveEmptyEntries);
    	//		switch(arr.Length)//TODO: use a better expression here rahter than based on length 
    	//		{
    	//			case 1:
    	//				return (item =>  item.MessageRead != null  &&  item.MessageRead.ToLower().Contains(value));
    	//			case 2:
    	//				 {
    	//				  string v1=arr[0].Replace(separator,"");
    	//				  string v2=arr[1].Replace(separator,"");				
    	//				 return (item =>  item.MessageRead != null  &&  item.MessageRead.ToLower().Contains(v1)  &&  item.MessageRead.ToLower().Contains(v2) );		
    	//				}
    	//			default:
    	//				 {
    	//				   string v1=arr[0].Replace(separator,"");
    	//				  string v2=arr[1].Replace(separator,"");
    	//				  string v3=arr[2].Replace(separator,"");
    	//				return (item =>  item.MessageRead != null  &&  item.MessageRead.ToLower().Contains(v1) &&  item.MessageRead.ToLower().Contains(v2) &&  item.MessageRead.ToLower().Contains(v3) );
    	//				}
    	//
    	//		}
    	//			
    	//
    	//	};	 
    	// public static Func<string, Expression<Func<smsg_Message, bool>>> fexp_MessageReadContainsMultipleDef = value => fexp_MessageReadContainsMultiple(value, "%");
        
       
        
        public smsg_Message_FindDB(ColList<smsg_Message> col):base(col)
        {
     
            
        
                    
        }
        
    
        
        
        public IQueryable<smsg_Message> LoadFrom_IDMessageQ(long Value)
                {
                    
                    return LoadFrom1PropertyQ(exp_IDMessage, Value);
    
                }
        public void LoadFrom_IDMessage(long Value)
                {
                    
                    this.LoadFromQueryable( LoadFrom_IDMessageQ(Value));
    
                }
        public IQueryable<smsg_Message> LoadFindIDsColumn_IDMessageQ(long[] ColumnValues)
        {
            return LoadFindIDsColumnQ<long>(ColumnValues,"IDMessage"); 
        }
        public void LoadFindIDsColumn_IDMessage(long[] ColumnValues)
        {
            this.LoadFromQueryable(LoadFindIDsColumnQ<long>(ColumnValues,"IDMessage")); 
        }
    
    
    	public IQueryable<smsg_Message> LoadFindIDsColumn_IDMessageQ(List<long> ColumnValues)
        {
            return LoadFindIDsColumn_IDMessageQ(ColumnValues.ToArray<long>()); 
        }
        public void LoadFindIDsColumn_IDMessage(List<long> ColumnValues)
        {
            this.LoadFindIDsColumn_IDMessage(ColumnValues.ToArray<long>()); 
        }
                
        public IQueryable<smsg_Message> LoadFrom_SubjectQ(string Value)
                {
                    
                    return LoadFrom1PropertyQ(exp_Subject, Value);
    
                }
        public void LoadFrom_Subject(string Value)
                {
                    
                    this.LoadFromQueryable( LoadFrom_SubjectQ(Value));
    
                }
        public IQueryable<smsg_Message> LoadFindIDsColumn_SubjectQ(string[] ColumnValues)
        {
            return LoadFindIDsColumnQ<string>(ColumnValues,"Subject"); 
        }
        public void LoadFindIDsColumn_Subject(string[] ColumnValues)
        {
            this.LoadFromQueryable(LoadFindIDsColumnQ<string>(ColumnValues,"Subject")); 
        }
    
    
    	public IQueryable<smsg_Message> LoadFindIDsColumn_SubjectQ(List<string> ColumnValues)
        {
            return LoadFindIDsColumn_SubjectQ(ColumnValues.ToArray<string>()); 
        }
        public void LoadFindIDsColumn_Subject(List<string> ColumnValues)
        {
            this.LoadFindIDsColumn_Subject(ColumnValues.ToArray<string>()); 
        }
                
        public IQueryable<smsg_Message> LoadFrom_BodyQ(string Value)
                {
                    
                    return LoadFrom1PropertyQ(exp_Body, Value);
    
                }
        public void LoadFrom_Body(string Value)
                {
                    
                    this.LoadFromQueryable( LoadFrom_BodyQ(Value));
    
                }
        public IQueryable<smsg_Message> LoadFindIDsColumn_BodyQ(string[] ColumnValues)
        {
            return LoadFindIDsColumnQ<string>(ColumnValues,"Body"); 
        }
        public void LoadFindIDsColumn_Body(string[] ColumnValues)
        {
            this.LoadFromQueryable(LoadFindIDsColumnQ<string>(ColumnValues,"Body")); 
        }
    
    
    	public IQueryable<smsg_Message> LoadFindIDsColumn_BodyQ(List<string> ColumnValues)
        {
            return LoadFindIDsColumn_BodyQ(ColumnValues.ToArray<string>()); 
        }
        public void LoadFindIDsColumn_Body(List<string> ColumnValues)
        {
            this.LoadFindIDsColumn_Body(ColumnValues.ToArray<string>()); 
        }
                
        public IQueryable<smsg_Message> LoadFrom_FromUserQ(string Value)
                {
                    
                    return LoadFrom1PropertyQ(exp_FromUser, Value);
    
                }
        public void LoadFrom_FromUser(string Value)
                {
                    
                    this.LoadFromQueryable( LoadFrom_FromUserQ(Value));
    
                }
        public IQueryable<smsg_Message> LoadFindIDsColumn_FromUserQ(string[] ColumnValues)
        {
            return LoadFindIDsColumnQ<string>(ColumnValues,"FromUser"); 
        }
        public void LoadFindIDsColumn_FromUser(string[] ColumnValues)
        {
            this.LoadFromQueryable(LoadFindIDsColumnQ<string>(ColumnValues,"FromUser")); 
        }
    
    
    	public IQueryable<smsg_Message> LoadFindIDsColumn_FromUserQ(List<string> ColumnValues)
        {
            return LoadFindIDsColumn_FromUserQ(ColumnValues.ToArray<string>()); 
        }
        public void LoadFindIDsColumn_FromUser(List<string> ColumnValues)
        {
            this.LoadFindIDsColumn_FromUser(ColumnValues.ToArray<string>()); 
        }
                
        public IQueryable<smsg_Message> LoadFrom_ToUserQ(string Value)
                {
                    
                    return LoadFrom1PropertyQ(exp_ToUser, Value);
    
                }
        public void LoadFrom_ToUser(string Value)
                {
                    
                    this.LoadFromQueryable( LoadFrom_ToUserQ(Value));
    
                }
        public IQueryable<smsg_Message> LoadFindIDsColumn_ToUserQ(string[] ColumnValues)
        {
            return LoadFindIDsColumnQ<string>(ColumnValues,"ToUser"); 
        }
        public void LoadFindIDsColumn_ToUser(string[] ColumnValues)
        {
            this.LoadFromQueryable(LoadFindIDsColumnQ<string>(ColumnValues,"ToUser")); 
        }
    
    
    	public IQueryable<smsg_Message> LoadFindIDsColumn_ToUserQ(List<string> ColumnValues)
        {
            return LoadFindIDsColumn_ToUserQ(ColumnValues.ToArray<string>()); 
        }
        public void LoadFindIDsColumn_ToUser(List<string> ColumnValues)
        {
            this.LoadFindIDsColumn_ToUser(ColumnValues.ToArray<string>()); 
        }
                
        public IQueryable<smsg_Message> LoadFrom_DateInsertedQ(System.DateTime Value)
                {
                    
                    return LoadFrom1PropertyQ(exp_DateInserted, Value);
    
                }
        public void LoadFrom_DateInserted(System.DateTime Value)
                {
                    
                    this.LoadFromQueryable( LoadFrom_DateInsertedQ(Value));
    
                }
        public IQueryable<smsg_Message> LoadFindIDsColumn_DateInsertedQ(System.DateTime[] ColumnValues)
        {
            return LoadFindIDsColumnQ<System.DateTime>(ColumnValues,"DateInserted"); 
        }
        public void LoadFindIDsColumn_DateInserted(System.DateTime[] ColumnValues)
        {
            this.LoadFromQueryable(LoadFindIDsColumnQ<System.DateTime>(ColumnValues,"DateInserted")); 
        }
    
    
    	public IQueryable<smsg_Message> LoadFindIDsColumn_DateInsertedQ(List<System.DateTime> ColumnValues)
        {
            return LoadFindIDsColumn_DateInsertedQ(ColumnValues.ToArray<System.DateTime>()); 
        }
        public void LoadFindIDsColumn_DateInserted(List<System.DateTime> ColumnValues)
        {
            this.LoadFindIDsColumn_DateInserted(ColumnValues.ToArray<System.DateTime>()); 
        }
                
        public IQueryable<smsg_Message> LoadFrom_MessageReadQ(bool Value)
                {
                    
                    return LoadFrom1PropertyQ(exp_MessageRead, Value);
    
                }
        public void LoadFrom_MessageRead(bool Value)
                {
                    
                    this.LoadFromQueryable( LoadFrom_MessageReadQ(Value));
    
                }
        public IQueryable<smsg_Message> LoadFindIDsColumn_MessageReadQ(bool[] ColumnValues)
        {
            return LoadFindIDsColumnQ<bool>(ColumnValues,"MessageRead"); 
        }
        public void LoadFindIDsColumn_MessageRead(bool[] ColumnValues)
        {
            this.LoadFromQueryable(LoadFindIDsColumnQ<bool>(ColumnValues,"MessageRead")); 
        }
    
    
    	public IQueryable<smsg_Message> LoadFindIDsColumn_MessageReadQ(List<bool> ColumnValues)
        {
            return LoadFindIDsColumn_MessageReadQ(ColumnValues.ToArray<bool>()); 
        }
        public void LoadFindIDsColumn_MessageRead(List<bool> ColumnValues)
        {
            this.LoadFindIDsColumn_MessageRead(ColumnValues.ToArray<bool>()); 
        }
                
        private IQueryable<smsg_Message> LoadFrom1PropertyQ<T>(Expression<Func<smsg_Message, T>> property, T Value)
                {
                    var iq = HelperExpressions.PredicateBinary<T, smsg_Message >(property, Value, "equal");
                    return ObjectSetWithInclude().Where(iq);
    
                }
        
        public void LoadFrom1Property<T>(Expression<Func<smsg_Message, T>> property, T Value)
                {
                    
                    this.LoadFromQueryable(LoadFrom1PropertyQ(property,Value));
    
                }
                public void LoadFrom2Property<T,U>(Expression<Func<smsg_Message, T>> property1, T Value1, Expression<Func<smsg_Message, U>> property2, U Value2,bool And)
                {
                    var iq = HelperExpressions.PredicateBinary<T, smsg_Message >(property1, Value1, "equal");
                    if(And)
                    {
                        iq =EFRebinder.Utility.AndRebind(iq, HelperExpressions.PredicateBinary<U, smsg_Message >(property2, Value2, "equal"));
                    }
                    else
                    {
                        iq =EFRebinder.Utility.OrRebind(iq, HelperExpressions.PredicateBinary<U, smsg_Message >(property2, Value2, "equal"));
                    }
                    this.LoadFromQueryable(ObjectSetWithInclude().Where(iq));
    
                }
        public void LoadFindIDsColumn<T>(T[] ColumnValues,string ColumnName)
        {
            this.LoadFromQueryable(LoadFindIDsColumnQ(ColumnValues,ColumnName));
        }
        public IQueryable<smsg_Message> LoadFindIDsColumnQ<T>(T[] ColumnValues,string ColumnName)
        {
    	//TODO: do this with buildcontains
            bool IsString = (typeof(T).FullName == typeof(string).FullName);
    
            string where="";
            string whereTemplate="it.{0} in ({1})";            
            if (ColumnValues != null && ColumnValues.Length > 0)
                {
                        
                    string inID = "{" + string.Join(", ", ColumnValues) + "}";
                    if (IsString)
                    {
                        inID ="";
                        foreach (var item in ColumnValues)
                        {
                            inID += string.Format("'{0}',", item.ToString().Replace("'","''"));
                        }
                        inID = inID.Substring(0, inID.Length - 1);
    					inID = "{" + inID + "}";
                    }
                    where += string.Format(whereTemplate, ColumnName, inID);
                }
                if (where.Length == 0)
                    return null;
                //return ObjectSetWithInclude().Where(where);
    			return null;
        }
        public IQueryable<smsg_Message> LoadFindIDsQ(long[] IDMessage)
      {
        
            var find = BuildContainsExpression(exp_IDMessage,IDMessage);			
            return ObjectSetWithInclude().Where(find);
      }
        public IQueryable<smsg_Message> LoadFromPKQ(long IDMessage)
        {
            //FindPartial.IDMessage = IDMessage;
    
            //return ObjectSetWithInclude().Where(PredicateID());
    		return null;		
        }
        public smsg_Message LoadFromPK(long IDMessage)
        {
    
            this.LoadFromQueryable(LoadFromPKQ( IDMessage));
                
            if(this.ColToLoad.Count == 1)
            {
                return this.ColToLoad[0];
            }
            throw new ExceptionUtils.NoElementFoundException( IDMessage);
            //return null;
        }
        
        #region include 
            
         public enum Include : ulong { None = 0/*1*/,Include_smsg_MessageThread=1/*2*/,Include_smsg_MessageThread_smsg_Message_Archive=2,All = 3}
         public Include flaginclude =Include.None;

        #endregion
    
    private IQueryable<smsg_Message> ObjectSetWithInclude()
        {
            IQueryable<smsg_Message> ret=this.ColToLoad.SelfObjectSet;
            if ((flaginclude & Include.Include_smsg_MessageThread) == Include.Include_smsg_MessageThread) 
     ret = ret.Include("smsg_MessageThread");
    if ((flaginclude & Include.Include_smsg_MessageThread_smsg_Message_Archive) == Include.Include_smsg_MessageThread_smsg_Message_Archive) 
     ret = ret.Include("smsg_MessageThread.smsg_Message_Archive");
    
            return ret;
        }
        public  void LoadFindCustomPredicate()
        {
                this.LoadFromQueryable(LoadFindCustomPredicateQ());		  
        }
    	public IOrderedQueryable<smsg_Message> LoadFindCustomPredicateOrderedQ(string FieldName){
    		return OrderByField(LoadFindCustomPredicateQ(),FieldName);
    	}
        public  IQueryable<smsg_Message> LoadFindCustomPredicateQ()
      {
    	var ret=ObjectSetWithInclude();
    	if( custompredicate != null)
    	{
    		ret=ret.Where (custompredicate);;
    	}
    	return ret;
        //      return ObjectSetWithInclude().Where (custompredicate);
    
       }
    	public static IOrderedQueryable<smsg_Message> OrderByField(IQueryable<smsg_Message> var, string Field1) { 
    	if(string.IsNullOrEmpty(Field1))
    		return null;//TODO : return by PK
    
    	IOrderedQueryable<smsg_Message> ret=null;
    
    	switch(Field1)
    	{
    			
    	case "IDMessage": ret=var.OrderBy(exp_IDMessage);break;
    case "Subject": ret=var.OrderBy(exp_Subject);break;
    case "Body": ret=var.OrderBy(exp_Body);break;
    case "FromUser": ret=var.OrderBy(exp_FromUser);break;
    case "ToUser": ret=var.OrderBy(exp_ToUser);break;
    case "DateInserted": ret=var.OrderBy(exp_DateInserted);break;
    case "MessageRead": ret=var.OrderBy(exp_MessageRead);break;
    
    	}
    	return ret;
    	}
    }
    
    
    
}
